import * as fs from 'fs';
import * as path from 'path';
import { config } from '../config/environment';
import { getKeycloakToken, makeAuthenticatedRequest, formDataRequest } from '../utils/apiUtils';
import { eventTitles, eventCategories, getRandomEventDescription, getRandomEventOverview } from './eventData';
import { sriLankaLocations } from './locations';

// UUID generation function (to avoid dependency)
function generateUUID(): string {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
    const r = Math.random() * 16 | 0;
    const v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}

interface SeedData {
  organizationId: string;
  events: {
    id: string;
    title: string;
    sessionId: string;
  }[];
}

async function wait(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function seedEvents(): Promise<void> {
  console.log('Starting event seeding process...');
  console.log(`Will create ${config.eventCount || 30} events.`);
  
  // Step 1: Get authentication tokens
  console.log('Authenticating user...');
  const userToken = await getKeycloakToken(config.username, config.password);
  const adminToken = await getKeycloakToken(config.adminUsername, config.adminPassword);
  
  // Step 2: Create organization
  console.log('Creating organization...');
  const orgData = { name: "Ticketly Seeded Organization" };
  const orgResponse = await makeAuthenticatedRequest('post', `${config.eventCommandServiceUrl}/v1/organizations`, userToken, orgData);
  const organizationId = orgResponse.id;
  console.log(`Organization created with ID: ${organizationId}`);
  
  // Step 3: Fetch categories
  console.log('Fetching event categories...');
  const categoriesResponse = await makeAuthenticatedRequest('get', `${config.eventCommandServiceUrl}/v1/categories`, userToken);
  
  // Prepare data to track created events for cleanup
  const seedData: SeedData = {
    organizationId,
    events: []
  };
  
  // Step 4: Read image files from assets directory
  console.log('Reading image files from assets directory...');
  const imagesDir = config.imagesDir;
  let imageFiles: string[] = [];
  try {
    imageFiles = fs.readdirSync(imagesDir)
      .filter(file => /\.(jpg|jpeg|png|gif)$/i.test(file))
      .map(file => path.join(imagesDir, file));
    console.log(`Found ${imageFiles.length} image files.`);
  } catch (error) {
    console.error('Error reading image directory:', error);
    imageFiles = [];
  }

  // Calculate dates for events starting one week from now
  const today = new Date();
  const startDate = new Date(today);
  startDate.setDate(startDate.getDate() + 7); // Start events one week from today
  
  // Step 5: Create events
  const eventCount = Math.min(config.eventCount || 30, imageFiles.length || 30);
  console.log(`Creating ${eventCount} events...`);
  
  for (let i = 0; i < eventCount; i++) {
    try {
      // Pick random title, category, and location
      const title = eventTitles[i % eventTitles.length];
      const category = eventCategories[i % eventCategories.length];
      const location = sriLankaLocations[i % sriLankaLocations.length];
      
      // Calculate event date (one day apart starting from startDate)
      const eventDate = new Date(startDate);
      eventDate.setDate(eventDate.getDate() + i);
      
      // Event start and end time (2 hours duration)
      const startTime = new Date(eventDate);
      startTime.setHours(13, 30, 0, 0);
      const endTime = new Date(eventDate);
      endTime.setHours(15, 30, 0, 0);
      
      // Sales start time (15 mins from now)
      const salesStartTime = new Date();
      salesStartTime.setMinutes(salesStartTime.getMinutes() + 15);
      
      // Generate unique IDs
      const tierId = generateUUID();
      const sessionId = generateUUID();
      const discountId = generateUUID();
      
      // Create event JSON template
      const eventData = {
        title,
        description: getRandomEventDescription(title),
        overview: getRandomEventOverview(title),
        organizationId,
        categoryId: category.id,
        categoryName: category.name,
        tiers: [
          {
            id: tierId,
            name: "General Admission",
            price: 1000 + (i * 100), // Vary prices a bit
            color: "#3B82F6"
          }
        ],
        sessions: [
          {
            id: sessionId,
            startTime: startTime.toISOString(),
            endTime: endTime.toISOString(),
            salesStartTime: salesStartTime.toISOString(),
            sessionType: "PHYSICAL",
            venueDetails: {
              name: location.name + " Event Center",
              address: location.name,
              latitude: location.latitude,
              longitude: location.longitude
            },
            layoutData: {
              name: `${location.name} Layout`,
              layout: {
                blocks: [
                  {
                    id: uuidv4(),
                    name: "Main seating area",
                    type: "seated_grid",
                    position: {
                      x: 86.6666259765625,
                      y: 133.33335876464844
                    },
                    rows: [
                      {
                        id: uuidv4(),
                        label: "A",
                        seats: [
                          {
                            id: uuidv4(),
                            label: "1A",
                            tierId,
                            status: "AVAILABLE"
                          },
                          {
                            id: uuidv4(),
                            label: "2A",
                            tierId,
                            status: "AVAILABLE"
                          }
                        ]
                      },
                      {
                        id: uuidv4(),
                        label: "B",
                        seats: [
                          {
                            id: uuidv4(),
                            label: "1B",
                            tierId,
                            status: "AVAILABLE"
                          },
                          {
                            id: uuidv4(),
                            label: "2B",
                            tierId,
                            status: "AVAILABLE"
                          }
                        ]
                      }
                    ],
                    capacity: null,
                    width: null,
                    height: null,
                    seats: []
                  },
                  {
                    id: uuidv4(),
                    name: "stage",
                    type: "non_sellable",
                    position: {
                      x: 25,
                      y: 25
                    },
                    rows: [],
                    capacity: null,
                    width: 325,
                    height: 80,
                    seats: []
                  }
                ]
              }
            }
          }
        ],
        discounts: [
          {
            id: discountId,
            code: `SAVE${10 + i}`,
            maxUsage: null,
            currentUsage: 0,
            discountedTotal: 0,
            active: true,
            public: true,
            activeFrom: null,
            expiresAt: null,
            applicableTierIds: [tierId],
            applicableSessionIds: [sessionId],
            parameters: {
              type: "PERCENTAGE",
              percentage: 10,
              minSpend: 10,
              maxDiscount: null
            }
          }
        ]
      };
      
      // Create the event
      console.log(`Creating event ${i + 1}/${eventCount}: ${title}`);
      
      // Create event (with or without image)
      let eventResponse;
      if (imageFiles.length > 0) {
        const imageFile = imageFiles[i % imageFiles.length];
        console.log(`Using image: ${path.basename(imageFile)}`);
        eventResponse = await formDataRequest(`${config.eventCommandServiceUrl}/v1/events`, JSON.stringify(eventData), userToken, imageFile);
      } else {
        eventResponse = await formDataRequest(`${config.eventCommandServiceUrl}/v1/events`, JSON.stringify(eventData), userToken);
      }
      
      const eventId = eventResponse.id;
      console.log(`Created event with ID: ${eventId}`);
      
      // Approve the event using admin token
      console.log(`Approving event: ${eventId}`);
      await makeAuthenticatedRequest('post', `${config.eventCommandServiceUrl}/v1/events/${eventId}/approve`, adminToken);
      console.log(`Event approved: ${eventId}`);
      
      // Wait for event to propagate to query service
      console.log('Waiting for event propagation...');
      await wait(5000); // Wait 5 seconds
      
      // Put session on sale
      console.log(`Setting session ${sessionId} to ON_SALE`);
      await makeAuthenticatedRequest(
        'put', 
        `${config.eventCommandServiceUrl}/v1/sessions/${sessionId}/status`, 
        userToken, 
        { status: 'ON_SALE' }
      );
      
      // Store event data for later cleanup
      seedData.events.push({
        id: eventId,
        title,
        sessionId
      });
      
      // Wait between event creations
      if (i < eventCount - 1) {
        console.log('Waiting before creating next event...');
        await wait(2000);
      }
    } catch (error) {
      console.error(`Error creating event ${i + 1}:`, error);
    }
  }
  
  // Save seed data to file for cleanup
  const outputPath = config.seedDataOutputPath || path.join(process.cwd(), 'seed-data.json');
  fs.writeFileSync(outputPath, JSON.stringify(seedData, null, 2));
  console.log(`Seed data saved to ${outputPath}`);
  
  console.log('Event seeding completed!');
  console.log(`Created 1 organization and ${seedData.events.length} events.`);
}

// Check if this is being run directly
if (require.main === module) {
  seedEvents().catch(error => {
    console.error('Error during seeding:', error);
    process.exit(1);
  });
}

export { seedEvents };